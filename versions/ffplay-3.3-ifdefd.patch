--- ffplay-3.3.c	2017-04-15 09:20:05.000000000 +0200
+++ ffplay-3.3-ifdefd.c	2017-04-15 10:31:10.000000000 +0200
@@ -24,6 +24,13 @@
  */
 
 #include "config.h"
+//#define AUDIO
+//#define SUBTITLE
+//#define EXTCLOCK
+//#define FRAMEDROP
+#undef CONFIG_AVFILTER
+#undef CONFIG_RTSP_DEMUXER
+#undef CONFIG_AVDEVICE
 #include <inttypes.h>
 #include <math.h>
 #include <limits.h>
@@ -65,9 +72,12 @@
 
 #define MAX_QUEUE_SIZE (15 * 1024 * 1024)
 #define MIN_FRAMES 25
+#ifdef EXTCLOCK
 #define EXTERNAL_CLOCK_MIN_FRAMES 2
 #define EXTERNAL_CLOCK_MAX_FRAMES 10
+#endif
 
+#ifdef AUDIO
 /* Minimum SDL audio buffer size, in samples. */
 #define SDL_AUDIO_MIN_BUFFER_SIZE 512
 /* Calculate actual buffer size keeping in mind not cause too frequent audio callbacks */
@@ -75,6 +85,7 @@
 
 /* Step size for volume control in dB */
 #define SDL_VOLUME_STEP (0.75)
+#endif
 
 /* no AV sync correction is done if below the minimum AV sync threshold */
 #define AV_SYNC_THRESHOLD_MIN 0.04
@@ -85,23 +96,31 @@
 /* no AV correction is done if too big error */
 #define AV_NOSYNC_THRESHOLD 10.0
 
+#ifdef AUDIO
 /* maximum audio speed change to get correct sync */
 #define SAMPLE_CORRECTION_PERCENT_MAX 10
+#endif
 
+#ifdef EXTCLOCK
 /* external clock speed adjustment constants for realtime sources based on buffer fullness */
 #define EXTERNAL_CLOCK_SPEED_MIN  0.900
 #define EXTERNAL_CLOCK_SPEED_MAX  1.010
 #define EXTERNAL_CLOCK_SPEED_STEP 0.001
+#endif
 
+#ifdef AUDIO
 /* we use about AUDIO_DIFF_AVG_NB A-V differences to make the average */
 #define AUDIO_DIFF_AVG_NB   20
+#endif
 
 /* polls for possible required screen refresh at least this often, should be less than 1/fps */
 #define REFRESH_RATE 0.01
 
+#ifdef AUDIO
 /* NOTE: the size must be big enough to compensate the hardware audio buffersize size */
 /* TODO: We assume that a decoded and resampled frame fits into this buffer */
 #define SAMPLE_ARRAY_SIZE (8 * 65536)
+#endif
 
 #define CURSOR_HIDE_DELAY 1000000
 
@@ -131,6 +150,7 @@
 #define SAMPLE_QUEUE_SIZE 9
 #define FRAME_QUEUE_SIZE FFMAX(SAMPLE_QUEUE_SIZE, FFMAX(VIDEO_PICTURE_QUEUE_SIZE, SUBPICTURE_QUEUE_SIZE))
 
+#ifdef AUDIO
 typedef struct AudioParams {
     int freq;
     int channels;
@@ -139,6 +159,7 @@
     int frame_size;
     int bytes_per_sec;
 } AudioParams;
+#endif
 
 typedef struct Clock {
     double pts;           /* clock base */
@@ -153,7 +174,9 @@
 /* Common struct for handling all types of decoded data and allocated render buffers. */
 typedef struct Frame {
     AVFrame *frame;
+#ifdef SUBTITLE
     AVSubtitle sub;
+#endif
     int serial;
     double pts;           /* presentation timestamp for the frame */
     double duration;      /* estimated duration of the frame */
@@ -180,9 +203,13 @@
 } FrameQueue;
 
 enum {
+#ifdef AUDIO
     AV_SYNC_AUDIO_MASTER, /* default choice */
+#endif
     AV_SYNC_VIDEO_MASTER,
+#ifdef EXTCLOCK
     AV_SYNC_EXTERNAL_CLOCK, /* synchronize to an external clock */
+#endif
 };
 
 typedef struct Decoder {
@@ -217,22 +244,33 @@
     AVFormatContext *ic;
     int realtime;
 
+#ifdef AUDIO
     Clock audclk;
+#endif
     Clock vidclk;
+#ifdef EXTCLOCK
     Clock extclk;
+#endif
 
     FrameQueue pictq;
+#ifdef SUBTITLE
     FrameQueue subpq;
+#endif
+#ifdef AUDIO
     FrameQueue sampq;
+#endif
 
     Decoder auddec;
     Decoder viddec;
     Decoder subdec;
 
+#ifdef AUDIO
     int audio_stream;
+#endif
 
     int av_sync_type;
 
+#ifdef AUDIO
     double audio_clock;
     int audio_clock_serial;
     double audio_diff_cum; /* used for AV difference average computation */
@@ -256,12 +294,22 @@
 #endif
     struct AudioParams audio_tgt;
     struct SwrContext *swr_ctx;
+#endif
+#ifdef FRAMEDROP
     int frame_drops_early;
     int frame_drops_late;
+#endif
 
     enum ShowMode {
-        SHOW_MODE_NONE = -1, SHOW_MODE_VIDEO = 0, SHOW_MODE_WAVES, SHOW_MODE_RDFT, SHOW_MODE_NB
+        SHOW_MODE_NONE = -1,
+        SHOW_MODE_VIDEO = 0,
+#ifdef AUDIO                
+        SHOW_MODE_WAVES,
+        SHOW_MODE_RDFT,
+#endif
+        SHOW_MODE_NB
     } show_mode;
+#ifdef AUDIO
     int16_t sample_array[SAMPLE_ARRAY_SIZE];
     int sample_array_index;
     int last_i_start;
@@ -271,12 +319,17 @@
     int xpos;
     double last_vis_time;
     SDL_Texture *vis_texture;
+#endif
+#ifdef SUBTITLE
     SDL_Texture *sub_texture;
+#endif
     SDL_Texture *vid_texture;
 
+#ifdef SUBTITLE
     int subtitle_stream;
     AVStream *subtitle_st;
     PacketQueue subtitleq;
+#endif
 
     double frame_timer;
     double frame_last_returned_time;
@@ -286,7 +339,9 @@
     PacketQueue videoq;
     double max_frame_duration;      // maximum duration of a frame - above this, we consider the jump a timestamp discontinuity
     struct SwsContext *img_convert_ctx;
+#ifdef SUBTITLE
     struct SwsContext *sub_convert_ctx;
+#endif
     int eof;
 
     char *filename;
@@ -297,12 +352,23 @@
     int vfilter_idx;
     AVFilterContext *in_video_filter;   // the first filter in the video chain
     AVFilterContext *out_video_filter;  // the last filter in the video chain
+#ifdef AUDIO
     AVFilterContext *in_audio_filter;   // the first filter in the audio chain
     AVFilterContext *out_audio_filter;  // the last filter in the audio chain
     AVFilterGraph *agraph;              // audio filter graph
 #endif
+#endif
 
+#if 0
     int last_video_stream, last_audio_stream, last_subtitle_stream;
+#endif
+    int last_video_stream;
+#ifdef AUDIO
+    int last_audio_stream;
+#endif
+#ifdef SUBTITLE
+    int last_subtitle_stream;
+#endif
 
     SDL_cond *continue_read_thread;
 } VideoState;
@@ -315,16 +381,24 @@
 static int default_height = 480;
 static int screen_width  = 0;
 static int screen_height = 0;
+#ifdef AUDIO
 static int audio_disable;
+#endif
 static int video_disable;
+#ifdef SUBTITLE
 static int subtitle_disable;
+#endif
 static const char* wanted_stream_spec[AVMEDIA_TYPE_NB] = {0};
 static int seek_by_bytes = -1;
 static int display_disable;
 static int borderless;
 static int startup_volume = 100;
 static int show_status = 1;
+#ifdef AUDIO
 static int av_sync_type = AV_SYNC_AUDIO_MASTER;
+#else
+static int av_sync_type = AV_SYNC_VIDEO_MASTER;
+#endif
 static int64_t start_time = AV_NOPTS_VALUE;
 static int64_t duration = AV_NOPTS_VALUE;
 static int fast = 0;
@@ -335,11 +409,17 @@
 static int exit_on_keydown;
 static int exit_on_mousedown;
 static int loop = 1;
+#ifdef FRAMEDROP
 static int framedrop = -1;
+#endif
 static int infinite_buffer = -1;
 static enum ShowMode show_mode = SHOW_MODE_NONE;
+#ifdef AUDIO
 static const char *audio_codec_name;
+#endif
+#ifdef SUBTITLE
 static const char *subtitle_codec_name;
+#endif
 static const char *video_codec_name;
 double rdftspeed = 0.02;
 static int64_t cursor_last_shown;
@@ -347,13 +427,17 @@
 #if CONFIG_AVFILTER
 static const char **vfilters_list = NULL;
 static int nb_vfilters = 0;
+#ifdef AUDIO
 static char *afilters = NULL;
 #endif
+#endif
 static int autorotate = 1;
 
 /* current context */
 static int is_full_screen;
+#ifdef AUDIO
 static int64_t audio_callback_time;
+#endif
 
 static AVPacket flush_pkt;
 
@@ -371,6 +455,7 @@
 }
 #endif
 
+#ifdef AUDIO
 static inline
 int cmp_audio_fmts(enum AVSampleFormat fmt1, int64_t channel_count1,
                    enum AVSampleFormat fmt2, int64_t channel_count2)
@@ -390,6 +475,7 @@
     else
         return 0;
 }
+#endif
 
 static int packet_queue_put_private(PacketQueue *q, AVPacket *pkt)
 {
@@ -584,6 +670,9 @@
         switch (d->avctx->codec_type) {
             case AVMEDIA_TYPE_VIDEO:
                 ret = avcodec_decode_video2(d->avctx, frame, &got_frame, &d->pkt_temp);
+#ifdef DEBUG
+                printf("frame dts=%d pts=%d %s\n", (int)frame->pkt_dts, (int)frame->pkt_pts, got_frame ? "decoded!" : "");
+#endif
                 if (got_frame) {
                     if (decoder_reorder_pts == -1) {
                         frame->pts = av_frame_get_best_effort_timestamp(frame);
@@ -592,6 +681,7 @@
                     }
                 }
                 break;
+#ifdef AUDIO
             case AVMEDIA_TYPE_AUDIO:
                 ret = avcodec_decode_audio4(d->avctx, frame, &got_frame, &d->pkt_temp);
                 if (got_frame) {
@@ -606,9 +696,14 @@
                     }
                 }
                 break;
+#endif
+#ifdef SUBTITLE
             case AVMEDIA_TYPE_SUBTITLE:
                 ret = avcodec_decode_subtitle2(d->avctx, sub, &got_frame, &d->pkt_temp);
                 break;
+#endif
+            default:
+                break;
         }
 
         if (ret < 0) {
@@ -643,7 +738,9 @@
 static void frame_queue_unref_item(Frame *vp)
 {
     av_frame_unref(vp->frame);
+#ifdef SUBTITLE
     avsubtitle_free(&vp->sub);
+#endif
 }
 
 static int frame_queue_init(FrameQueue *f, PacketQueue *pktq, int max_size, int keep_last)
@@ -691,10 +788,12 @@
     return &f->queue[(f->rindex + f->rindex_shown) % f->max_size];
 }
 
+#if defined(SUBTITLE) || defined(FRAMEDROP)
 static Frame *frame_queue_peek_next(FrameQueue *f)
 {
     return &f->queue[(f->rindex + f->rindex_shown + 1) % f->max_size];
 }
+#endif
 
 static Frame *frame_queue_peek_last(FrameQueue *f)
 {
@@ -717,6 +816,7 @@
     return &f->queue[f->windex];
 }
 
+#ifdef AUDIO
 static Frame *frame_queue_peek_readable(FrameQueue *f)
 {
     /* wait until we have a readable a new frame */
@@ -732,6 +832,7 @@
 
     return &f->queue[(f->rindex + f->rindex_shown) % f->max_size];
 }
+#endif
 
 static void frame_queue_push(FrameQueue *f)
 {
@@ -783,6 +884,7 @@
     packet_queue_flush(d->queue);
 }
 
+#ifdef AUDIO
 static inline void fill_rectangle(int x, int y, int w, int h)
 {
     SDL_Rect rect;
@@ -793,6 +895,7 @@
     if (w && h)
         SDL_RenderFillRect(renderer, &rect);
 }
+#endif
 
 static int realloc_texture(SDL_Texture **texture, Uint32 new_format, int new_width, int new_height, SDL_BlendMode blendmode, int init_texture)
 {
@@ -891,10 +994,13 @@
 static void video_image_display(VideoState *is)
 {
     Frame *vp;
+#ifdef SUBTITLE
     Frame *sp = NULL;
+#endif
     SDL_Rect rect;
 
     vp = frame_queue_peek_last(&is->pictq);
+#ifdef SUBTITLE
     if (is->subtitle_st) {
         if (frame_queue_nb_remaining(&is->subpq) > 0) {
             sp = frame_queue_peek(&is->subpq);
@@ -939,6 +1045,7 @@
                 sp = NULL;
         }
     }
+#endif
 
     calculate_display_rect(&rect, is->xleft, is->ytop, is->width, is->height, vp->width, vp->height, vp->sar);
 
@@ -953,6 +1060,7 @@
     }
 
     SDL_RenderCopyEx(renderer, is->vid_texture, NULL, &rect, 0, NULL, vp->flip_v ? SDL_FLIP_VERTICAL : 0);
+#ifdef SUBTITLE
     if (sp) {
 #if USE_ONEPASS_SUBTITLE_RENDER
         SDL_RenderCopy(renderer, is->sub_texture, NULL, &rect);
@@ -970,8 +1078,10 @@
         }
 #endif
     }
+#endif
 }
 
+#ifdef AUDIO
 static inline int compute_mod(int a, int b)
 {
     return a < 0 ? a%b + b : a%b;
@@ -1118,6 +1228,7 @@
             s->xpos= s->xleft;
     }
 }
+#endif
 
 static void stream_component_close(VideoState *is, int stream_index)
 {
@@ -1130,6 +1241,7 @@
 
     switch (codecpar->codec_type) {
     case AVMEDIA_TYPE_AUDIO:
+#ifdef AUDIO
         decoder_abort(&is->auddec, &is->sampq);
         SDL_CloseAudio();
         decoder_destroy(&is->auddec);
@@ -1144,14 +1256,17 @@
             is->rdft = NULL;
             is->rdft_bits = 0;
         }
+#endif
         break;
     case AVMEDIA_TYPE_VIDEO:
         decoder_abort(&is->viddec, &is->pictq);
         decoder_destroy(&is->viddec);
         break;
     case AVMEDIA_TYPE_SUBTITLE:
+#ifdef SUBTITLE
         decoder_abort(&is->subdec, &is->subpq);
         decoder_destroy(&is->subdec);
+#endif
         break;
     default:
         break;
@@ -1160,16 +1275,20 @@
     ic->streams[stream_index]->discard = AVDISCARD_ALL;
     switch (codecpar->codec_type) {
     case AVMEDIA_TYPE_AUDIO:
+#ifdef AUDIO
         is->audio_st = NULL;
         is->audio_stream = -1;
+#endif
         break;
     case AVMEDIA_TYPE_VIDEO:
         is->video_st = NULL;
         is->video_stream = -1;
         break;
     case AVMEDIA_TYPE_SUBTITLE:
+#ifdef SUBTITLE
         is->subtitle_st = NULL;
         is->subtitle_stream = -1;
+#endif
         break;
     default:
         break;
@@ -1183,33 +1302,51 @@
     SDL_WaitThread(is->read_tid, NULL);
 
     /* close each stream */
+#ifdef AUDIO
     if (is->audio_stream >= 0)
         stream_component_close(is, is->audio_stream);
+#endif
     if (is->video_stream >= 0)
         stream_component_close(is, is->video_stream);
+#ifdef SUBTITLE
     if (is->subtitle_stream >= 0)
         stream_component_close(is, is->subtitle_stream);
+#endif
 
     avformat_close_input(&is->ic);
 
     packet_queue_destroy(&is->videoq);
+#ifdef AUDIO
     packet_queue_destroy(&is->audioq);
+#endif
+#ifdef SUBTITLE
     packet_queue_destroy(&is->subtitleq);
+#endif
 
     /* free all pictures */
     frame_queue_destory(&is->pictq);
+#ifdef AUDIO
     frame_queue_destory(&is->sampq);
+#endif
+#ifdef SUBTITLE
     frame_queue_destory(&is->subpq);
+#endif
     SDL_DestroyCond(is->continue_read_thread);
     sws_freeContext(is->img_convert_ctx);
+#ifdef SUBTITLE
     sws_freeContext(is->sub_convert_ctx);
+#endif
     av_free(is->filename);
+#ifdef AUDIO
     if (is->vis_texture)
         SDL_DestroyTexture(is->vis_texture);
+#endif
     if (is->vid_texture)
         SDL_DestroyTexture(is->vid_texture);
+#ifdef SUBTITLE
     if (is->sub_texture)
         SDL_DestroyTexture(is->sub_texture);
+#endif
     av_free(is);
 }
 
@@ -1307,10 +1444,15 @@
 
     SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
     SDL_RenderClear(renderer);
+#ifdef AUDIO
     if (is->audio_st && is->show_mode != SHOW_MODE_VIDEO)
         video_audio_display(is);
     else if (is->video_st)
         video_image_display(is);
+#else
+    if (is->video_st)
+        video_image_display(is);
+#endif
     SDL_RenderPresent(renderer);
 }
 
@@ -1340,11 +1482,13 @@
     set_clock_at(c, pts, serial, time);
 }
 
+#ifdef EXTCLOCK
 static void set_clock_speed(Clock *c, double speed)
 {
     set_clock(c, get_clock(c), c->serial);
     c->speed = speed;
 }
+#endif
 
 static void init_clock(Clock *c, int *queue_serial)
 {
@@ -1354,6 +1498,7 @@
     set_clock(c, NAN, -1);
 }
 
+#ifdef EXTCLOCK
 static void sync_clock_to_slave(Clock *c, Clock *slave)
 {
     double clock = get_clock(c);
@@ -1361,20 +1506,32 @@
     if (!isnan(slave_clock) && (isnan(clock) || fabs(clock - slave_clock) > AV_NOSYNC_THRESHOLD))
         set_clock(c, slave_clock, slave->serial);
 }
+#endif
 
 static int get_master_sync_type(VideoState *is) {
     if (is->av_sync_type == AV_SYNC_VIDEO_MASTER) {
         if (is->video_st)
             return AV_SYNC_VIDEO_MASTER;
+#ifdef AUDIO
         else
             return AV_SYNC_AUDIO_MASTER;
     } else if (is->av_sync_type == AV_SYNC_AUDIO_MASTER) {
         if (is->audio_st)
             return AV_SYNC_AUDIO_MASTER;
+#endif
+#ifdef EXTCLOCK
         else
             return AV_SYNC_EXTERNAL_CLOCK;
+#else
+        else
+            return AV_SYNC_VIDEO_MASTER;
+#endif
     } else {
+#ifdef EXTCLOCK
         return AV_SYNC_EXTERNAL_CLOCK;
+#else
+        return AV_SYNC_VIDEO_MASTER;
+#endif
     }
 }
 
@@ -1387,22 +1544,35 @@
         case AV_SYNC_VIDEO_MASTER:
             val = get_clock(&is->vidclk);
             break;
+#ifdef AUDIO
         case AV_SYNC_AUDIO_MASTER:
             val = get_clock(&is->audclk);
             break;
+#endif
         default:
+#ifdef EXTCLOCK
             val = get_clock(&is->extclk);
+#else
+            val = get_clock(&is->vidclk);
+#endif
             break;
     }
     return val;
 }
 
+#ifdef EXTCLOCK
 static void check_external_clock_speed(VideoState *is) {
-   if (is->video_stream >= 0 && is->videoq.nb_packets <= EXTERNAL_CLOCK_MIN_FRAMES ||
-       is->audio_stream >= 0 && is->audioq.nb_packets <= EXTERNAL_CLOCK_MIN_FRAMES) {
+   if (is->video_stream >= 0 && is->videoq.nb_packets <= EXTERNAL_CLOCK_MIN_FRAMES
+#ifdef AUDIO
+       || is->audio_stream >= 0 && is->audioq.nb_packets <= EXTERNAL_CLOCK_MIN_FRAMES
+#endif
+       ) {
        set_clock_speed(&is->extclk, FFMAX(EXTERNAL_CLOCK_SPEED_MIN, is->extclk.speed - EXTERNAL_CLOCK_SPEED_STEP));
-   } else if ((is->video_stream < 0 || is->videoq.nb_packets > EXTERNAL_CLOCK_MAX_FRAMES) &&
-              (is->audio_stream < 0 || is->audioq.nb_packets > EXTERNAL_CLOCK_MAX_FRAMES)) {
+   } else if ((is->video_stream < 0 || is->videoq.nb_packets > EXTERNAL_CLOCK_MAX_FRAMES)
+#ifdef AUDIO
+              && (is->audio_stream < 0 || is->audioq.nb_packets > EXTERNAL_CLOCK_MAX_FRAMES)
+#endif
+              ) {
        set_clock_speed(&is->extclk, FFMIN(EXTERNAL_CLOCK_SPEED_MAX, is->extclk.speed + EXTERNAL_CLOCK_SPEED_STEP));
    } else {
        double speed = is->extclk.speed;
@@ -1410,6 +1580,7 @@
            set_clock_speed(&is->extclk, speed + EXTERNAL_CLOCK_SPEED_STEP * (1.0 - speed) / fabs(1.0 - speed));
    }
 }
+#endif
 
 /* seek in the stream */
 static void stream_seek(VideoState *is, int64_t pos, int64_t rel, int seek_by_bytes)
@@ -1435,8 +1606,18 @@
         }
         set_clock(&is->vidclk, get_clock(&is->vidclk), is->vidclk.serial);
     }
+#ifdef EXTCLOCK
     set_clock(&is->extclk, get_clock(&is->extclk), is->extclk.serial);
-    is->paused = is->audclk.paused = is->vidclk.paused = is->extclk.paused = !is->paused;
+#endif
+    is->paused =
+#ifdef AUDIO
+    is->audclk.paused =
+#endif
+    is->vidclk.paused =
+#ifdef EXTCLOCK
+    is->extclk.paused =
+#endif
+        !is->paused;
 }
 
 static void toggle_pause(VideoState *is)
@@ -1445,6 +1626,7 @@
     is->step = 0;
 }
 
+#ifdef AUDIO
 static void toggle_mute(VideoState *is)
 {
     is->muted = !is->muted;
@@ -1456,6 +1638,7 @@
     int new_volume = lrint(SDL_MIX_MAXVOLUME * pow(10.0, (volume_level + sign * step) / 20.0));
     is->audio_volume = av_clip(is->audio_volume == new_volume ? (is->audio_volume + sign) : new_volume, 0, SDL_MIX_MAXVOLUME);
 }
+#endif
 
 static void step_to_next_frame(VideoState *is)
 {
@@ -1510,7 +1693,9 @@
 static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {
     /* update current video pts */
     set_clock(&is->vidclk, pts, serial);
+#ifdef EXTCLOCK
     sync_clock_to_slave(&is->extclk, &is->vidclk);
+#endif
 }
 
 /* called to display each frame */
@@ -1519,11 +1704,16 @@
     VideoState *is = opaque;
     double time;
 
+#ifdef SUBTITLE
     Frame *sp, *sp2;
+#endif
 
+#ifdef EXTCLOCK
     if (!is->paused && get_master_sync_type(is) == AV_SYNC_EXTERNAL_CLOCK && is->realtime)
         check_external_clock_speed(is);
+#endif
 
+#ifdef AUDIO
     if (!display_disable && is->show_mode != SHOW_MODE_VIDEO && is->audio_st) {
         time = av_gettime_relative() / 1000000.0;
         if (is->force_refresh || is->last_vis_time + rdftspeed < time) {
@@ -1532,6 +1722,7 @@
         }
         *remaining_time = FFMIN(*remaining_time, is->last_vis_time + rdftspeed - time);
     }
+#endif
 
     if (is->video_st) {
 retry:
@@ -1575,6 +1766,7 @@
                 update_video_pts(is, vp->pts, vp->pos, vp->serial);
             SDL_UnlockMutex(is->pictq.mutex);
 
+ #ifdef FRAMEDROP
             if (frame_queue_nb_remaining(&is->pictq) > 1) {
                 Frame *nextvp = frame_queue_peek_next(&is->pictq);
                 duration = vp_duration(is, vp, nextvp);
@@ -1584,7 +1776,9 @@
                     goto retry;
                 }
             }
+#endif
 
+#ifdef SUBTITLE
             if (is->subtitle_st) {
                     while (frame_queue_nb_remaining(&is->subpq) > 0) {
                         sp = frame_queue_peek(&is->subpq);
@@ -1618,6 +1812,7 @@
                         }
                     }
             }
+#endif
 
             frame_queue_next(&is->pictq);
             is->force_refresh = 1;
@@ -1642,25 +1837,42 @@
             aqsize = 0;
             vqsize = 0;
             sqsize = 0;
+#ifdef AUDIO
             if (is->audio_st)
                 aqsize = is->audioq.size;
+#endif
             if (is->video_st)
                 vqsize = is->videoq.size;
+#ifdef SUBTITLE
             if (is->subtitle_st)
                 sqsize = is->subtitleq.size;
+#endif
             av_diff = 0;
+#ifdef AUDIO
             if (is->audio_st && is->video_st)
                 av_diff = get_clock(&is->audclk) - get_clock(&is->vidclk);
             else if (is->video_st)
                 av_diff = get_master_clock(is) - get_clock(&is->vidclk);
             else if (is->audio_st)
                 av_diff = get_master_clock(is) - get_clock(&is->audclk);
+#else
+            if (is->video_st)
+                av_diff = get_master_clock(is) - get_clock(&is->vidclk);
+#endif
             av_log(NULL, AV_LOG_INFO,
                    "%7.2f %s:%7.3f fd=%4d aq=%5dKB vq=%5dKB sq=%5dB f=%"PRId64"/%"PRId64"   \r",
                    get_master_clock(is),
+#ifdef AUDIO
                    (is->audio_st && is->video_st) ? "A-V" : (is->video_st ? "M-V" : (is->audio_st ? "M-A" : "   ")),
+#else
+                   is->video_st ? "M-V" : "   ",
+#endif
                    av_diff,
+#ifdef FRAMEDROP
                    is->frame_drops_early + is->frame_drops_late,
+#else
+                   0,
+#endif
                    aqsize / 1024,
                    vqsize / 1024,
                    sqsize,
@@ -1718,6 +1930,7 @@
 
         frame->sample_aspect_ratio = av_guess_sample_aspect_ratio(is->ic, is->video_st, frame);
 
+#ifdef FRAMEDROP
         if (framedrop>0 || (framedrop && get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) {
             if (frame->pts != AV_NOPTS_VALUE) {
                 double diff = dpts - get_master_clock(is);
@@ -1731,6 +1944,7 @@
                 }
             }
         }
+#endif
     }
 
     return got_picture;
@@ -1872,6 +2086,7 @@
     return ret;
 }
 
+#ifdef AUDIO
 static int configure_audio_filters(VideoState *is, const char *afilters, int force_output_format)
 {
     static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE };
@@ -1947,8 +2162,10 @@
         avfilter_graph_free(&is->agraph);
     return ret;
 }
+#endif
 #endif  /* CONFIG_AVFILTER */
 
+#ifdef AUDIO
 static int audio_thread(void *arg)
 {
     VideoState *is = arg;
@@ -2035,6 +2252,7 @@
     av_frame_free(&frame);
     return ret;
 }
+#endif
 
 static int decoder_start(Decoder *d, int (*fn)(void *), void *arg)
 {
@@ -2156,6 +2374,7 @@
     return 0;
 }
 
+#ifdef SUBTITLE
 static int subtitle_thread(void *arg)
 {
     VideoState *is = arg;
@@ -2189,7 +2408,9 @@
     }
     return 0;
 }
+#endif
 
+#ifdef AUDIO
 /* copy samples for viewing in editor window */
 static void update_sample_display(VideoState *is, short *samples, int samples_size)
 {
@@ -2411,7 +2632,9 @@
     /* Let's assume the audio driver that is used by SDL has two periods. */
     if (!isnan(is->audio_clock)) {
         set_clock_at(&is->audclk, is->audio_clock - (double)(2 * is->audio_hw_buf_size + is->audio_write_buf_size) / is->audio_tgt.bytes_per_sec, is->audio_clock_serial, audio_callback_time / 1000000.0);
+#ifdef EXTCLOCK
         sync_clock_to_slave(&is->extclk, &is->audclk);
+#endif
     }
 }
 
@@ -2487,6 +2710,7 @@
     }
     return spec.size;
 }
+#endif
 
 /* open a given stream. Return 0 if OK */
 static int stream_component_open(VideoState *is, int stream_index)
@@ -2497,8 +2721,10 @@
     const char *forced_codec_name = NULL;
     AVDictionary *opts = NULL;
     AVDictionaryEntry *t = NULL;
+#ifdef AUDIO
     int sample_rate, nb_channels;
     int64_t channel_layout;
+#endif
     int ret = 0;
     int stream_lowres = lowres;
 
@@ -2517,9 +2743,15 @@
     codec = avcodec_find_decoder(avctx->codec_id);
 
     switch(avctx->codec_type){
+#ifdef AUDIO
         case AVMEDIA_TYPE_AUDIO   : is->last_audio_stream    = stream_index; forced_codec_name =    audio_codec_name; break;
+#endif
+#ifdef SUBTITLE
         case AVMEDIA_TYPE_SUBTITLE: is->last_subtitle_stream = stream_index; forced_codec_name = subtitle_codec_name; break;
+#endif
         case AVMEDIA_TYPE_VIDEO   : is->last_video_stream    = stream_index; forced_codec_name =    video_codec_name; break;
+        default:
+            break;
     }
     if (forced_codec_name)
         codec = avcodec_find_decoder_by_name(forced_codec_name);
@@ -2569,6 +2801,7 @@
     is->eof = 0;
     ic->streams[stream_index]->discard = AVDISCARD_DEFAULT;
     switch (avctx->codec_type) {
+#ifdef AUDIO
     case AVMEDIA_TYPE_AUDIO:
 #if CONFIG_AVFILTER
         {
@@ -2618,6 +2851,7 @@
             goto out;
         SDL_PauseAudio(0);
         break;
+#endif
     case AVMEDIA_TYPE_VIDEO:
         is->video_stream = stream_index;
         is->video_st = ic->streams[stream_index];
@@ -2627,6 +2861,7 @@
             goto out;
         is->queue_attachments_req = 1;
         break;
+#ifdef SUBTITLE
     case AVMEDIA_TYPE_SUBTITLE:
         is->subtitle_stream = stream_index;
         is->subtitle_st = ic->streams[stream_index];
@@ -2635,6 +2870,7 @@
         if ((ret = decoder_start(&is->subdec, subtitle_thread, is)) < 0)
             goto out;
         break;
+#endif
     default:
         break;
     }
@@ -2702,8 +2938,12 @@
 
     memset(st_index, -1, sizeof(st_index));
     is->last_video_stream = is->video_stream = -1;
+#ifdef AUDIO
     is->last_audio_stream = is->audio_stream = -1;
+#endif
+#ifdef SUBTITLE
     is->last_subtitle_stream = is->subtitle_stream = -1;
+#endif
     is->eof = 0;
 
     ic = avformat_alloc_context();
@@ -2805,12 +3045,15 @@
         st_index[AVMEDIA_TYPE_VIDEO] =
             av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,
                                 st_index[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);
+#ifdef AUDIO
     if (!audio_disable)
         st_index[AVMEDIA_TYPE_AUDIO] =
             av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,
                                 st_index[AVMEDIA_TYPE_AUDIO],
                                 st_index[AVMEDIA_TYPE_VIDEO],
                                 NULL, 0);
+#endif
+#ifdef SUBTITLE
     if (!video_disable && !subtitle_disable)
         st_index[AVMEDIA_TYPE_SUBTITLE] =
             av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,
@@ -2819,6 +3062,7 @@
                                  st_index[AVMEDIA_TYPE_AUDIO] :
                                  st_index[AVMEDIA_TYPE_VIDEO]),
                                 NULL, 0);
+#endif
 
     is->show_mode = show_mode;
     if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {
@@ -2830,22 +3074,35 @@
     }
 
     /* open the streams */
+#ifdef AUDIO
     if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {
         stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);
     }
+#endif
 
     ret = -1;
     if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {
         ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);
     }
+#ifdef AUDIO
     if (is->show_mode == SHOW_MODE_NONE)
         is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;
+#else
+    if (is->show_mode == SHOW_MODE_NONE && ret >= 0)
+        is->show_mode = SHOW_MODE_VIDEO;
+#endif
 
+#ifdef SUBTITLE
     if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {
         stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);
     }
+#endif
 
-    if (is->video_stream < 0 && is->audio_stream < 0) {
+    if (is->video_stream < 0
+#ifdef AUDIO
+        && is->audio_stream < 0
+#endif
+        ) {
         av_log(NULL, AV_LOG_FATAL, "Failed to open file '%s' or configure filtergraph\n",
                is->filename);
         ret = -1;
@@ -2887,23 +3144,29 @@
                 av_log(NULL, AV_LOG_ERROR,
                        "%s: error while seeking\n", is->ic->filename);
             } else {
+#ifdef AUDIO
                 if (is->audio_stream >= 0) {
                     packet_queue_flush(&is->audioq);
                     packet_queue_put(&is->audioq, &flush_pkt);
                 }
+#endif
+#ifdef SUBTITLE
                 if (is->subtitle_stream >= 0) {
                     packet_queue_flush(&is->subtitleq);
                     packet_queue_put(&is->subtitleq, &flush_pkt);
                 }
+#endif
                 if (is->video_stream >= 0) {
                     packet_queue_flush(&is->videoq);
                     packet_queue_put(&is->videoq, &flush_pkt);
                 }
+#ifdef EXTCLOCK
                 if (is->seek_flags & AVSEEK_FLAG_BYTE) {
                    set_clock(&is->extclk, NAN, 0);
                 } else {
                    set_clock(&is->extclk, seek_target / (double)AV_TIME_BASE, 0);
                 }
+#endif
             }
             is->seek_req = 0;
             is->queue_attachments_req = 1;
@@ -2924,10 +3187,25 @@
 
         /* if the queue are full, no need to read more */
         if (infinite_buffer<1 &&
-              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE
-            || (stream_has_enough_packets(is->audio_st, is->audio_stream, &is->audioq) &&
-                stream_has_enough_packets(is->video_st, is->video_stream, &is->videoq) &&
-                stream_has_enough_packets(is->subtitle_st, is->subtitle_stream, &is->subtitleq)))) {
+              (
+#ifdef AUDIO
+                  is->audioq.size +
+#endif
+                  is->videoq.size
+#ifdef SUBTITLE
+                  + is->subtitleq.size
+#endif
+                  > MAX_QUEUE_SIZE
+            || (
+#ifdef AUDIO
+                stream_has_enough_packets(is->audio_st, is->audio_stream, &is->audioq) &&
+#endif
+                stream_has_enough_packets(is->video_st, is->video_stream, &is->videoq)
+#ifdef SUBTITLE
+                &&
+                stream_has_enough_packets(is->subtitle_st, is->subtitle_stream, &is->subtitleq)
+#endif
+                ))) {
             /* wait 10 ms */
             SDL_LockMutex(wait_mutex);
             SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);
@@ -2935,7 +3213,9 @@
             continue;
         }
         if (!is->paused &&
+#ifdef AUDIO
             (!is->audio_st || (is->auddec.finished == is->audioq.serial && frame_queue_nb_remaining(&is->sampq) == 0)) &&
+#endif
             (!is->video_st || (is->viddec.finished == is->videoq.serial && frame_queue_nb_remaining(&is->pictq) == 0))) {
             if (loop != 1 && (!loop || --loop)) {
                 stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);
@@ -2949,10 +3229,14 @@
             if ((ret == AVERROR_EOF || avio_feof(ic->pb)) && !is->eof) {
                 if (is->video_stream >= 0)
                     packet_queue_put_nullpacket(&is->videoq, is->video_stream);
+#ifdef AUDIO
                 if (is->audio_stream >= 0)
                     packet_queue_put_nullpacket(&is->audioq, is->audio_stream);
+#endif
+#ifdef SUBTITLE
                 if (is->subtitle_stream >= 0)
                     packet_queue_put_nullpacket(&is->subtitleq, is->subtitle_stream);
+#endif
                 is->eof = 1;
             }
             if (ic->pb && ic->pb->error)
@@ -2972,13 +3256,18 @@
                 av_q2d(ic->streams[pkt->stream_index]->time_base) -
                 (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000
                 <= ((double)duration / 1000000);
+#ifdef AUDIO
         if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {
             packet_queue_put(&is->audioq, pkt);
-        } else if (pkt->stream_index == is->video_stream && pkt_in_play_range
+        } else
+#endif
+        if (pkt->stream_index == is->video_stream && pkt_in_play_range
                    && !(is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC)) {
             packet_queue_put(&is->videoq, pkt);
+#ifdef SUBTITLE
         } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {
             packet_queue_put(&is->subtitleq, pkt);
+#endif
         } else {
             av_packet_unref(pkt);
         }
@@ -3017,14 +3306,23 @@
     /* start video display */
     if (frame_queue_init(&is->pictq, &is->videoq, VIDEO_PICTURE_QUEUE_SIZE, 1) < 0)
         goto fail;
+#ifdef SUBTITLE
     if (frame_queue_init(&is->subpq, &is->subtitleq, SUBPICTURE_QUEUE_SIZE, 0) < 0)
         goto fail;
+#endif
+#ifdef AUDIO
     if (frame_queue_init(&is->sampq, &is->audioq, SAMPLE_QUEUE_SIZE, 1) < 0)
         goto fail;
+#endif
 
-    if (packet_queue_init(&is->videoq) < 0 ||
-        packet_queue_init(&is->audioq) < 0 ||
-        packet_queue_init(&is->subtitleq) < 0)
+    if (packet_queue_init(&is->videoq) < 0
+#ifdef AUDIO
+        || packet_queue_init(&is->audioq) < 0
+#endif
+#ifdef SUBTITLE
+        || packet_queue_init(&is->subtitleq) < 0
+#endif
+        )
         goto fail;
 
     if (!(is->continue_read_thread = SDL_CreateCond())) {
@@ -3033,8 +3331,13 @@
     }
 
     init_clock(&is->vidclk, &is->videoq.serial);
+#ifdef AUDIO
     init_clock(&is->audclk, &is->audioq.serial);
+#endif
+#ifdef EXTCLOCK
     init_clock(&is->extclk, &is->extclk.serial);
+#endif
+#ifdef AUDIO
     is->audio_clock_serial = -1;
     if (startup_volume < 0)
         av_log(NULL, AV_LOG_WARNING, "-volume=%d < 0, setting to 0\n", startup_volume);
@@ -3044,6 +3347,7 @@
     startup_volume = av_clip(SDL_MIX_MAXVOLUME * startup_volume / 100, 0, SDL_MIX_MAXVOLUME);
     is->audio_volume = startup_volume;
     is->muted = 0;
+#endif
     is->av_sync_type = av_sync_type;
     is->read_tid     = SDL_CreateThread(read_thread, "read_thread", is);
     if (!is->read_tid) {
@@ -3058,8 +3362,8 @@
 static void stream_cycle_channel(VideoState *is, int codec_type)
 {
     AVFormatContext *ic = is->ic;
-    int start_index, stream_index;
-    int old_index;
+    int start_index = -1, stream_index;
+    int old_index = -1;
     AVStream *st;
     AVProgram *p = NULL;
     int nb_streams = is->ic->nb_streams;
@@ -3067,12 +3371,16 @@
     if (codec_type == AVMEDIA_TYPE_VIDEO) {
         start_index = is->last_video_stream;
         old_index = is->video_stream;
+#ifdef AUDIO
     } else if (codec_type == AVMEDIA_TYPE_AUDIO) {
         start_index = is->last_audio_stream;
         old_index = is->audio_stream;
+#endif
+#ifdef SUBTITLE
     } else {
         start_index = is->last_subtitle_stream;
         old_index = is->subtitle_stream;
+#endif
     }
     stream_index = start_index;
 
@@ -3092,12 +3400,14 @@
     for (;;) {
         if (++stream_index >= nb_streams)
         {
+#ifdef SUBTITLE
             if (codec_type == AVMEDIA_TYPE_SUBTITLE)
             {
                 stream_index = -1;
                 is->last_subtitle_stream = -1;
                 goto the_end;
             }
+#endif
             if (start_index == -1)
                 return;
             stream_index = 0;
@@ -3108,13 +3418,17 @@
         if (st->codecpar->codec_type == codec_type) {
             /* check that parameters are OK */
             switch (codec_type) {
+#ifdef AUDIO
             case AVMEDIA_TYPE_AUDIO:
                 if (st->codecpar->sample_rate != 0 &&
                     st->codecpar->channels != 0)
                     goto the_end;
                 break;
+#endif
             case AVMEDIA_TYPE_VIDEO:
+#ifdef SUBTITLE
             case AVMEDIA_TYPE_SUBTITLE:
+#endif
                 goto the_end;
             default:
                 break;
@@ -3124,12 +3438,15 @@
  the_end:
     if (p && stream_index != -1)
         stream_index = p->stream_index[stream_index];
+    if (old_index == -1 && stream_index != -1)
     av_log(NULL, AV_LOG_INFO, "Switch %s stream from #%d to #%d\n",
            av_get_media_type_string(codec_type),
            old_index,
            stream_index);
 
+    if (old_index != -1)
     stream_component_close(is, old_index);
+    if (stream_index != -1)
     stream_component_open(is, stream_index);
 }
 
@@ -3140,6 +3457,7 @@
     SDL_SetWindowFullscreen(window, is_full_screen ? SDL_WINDOW_FULLSCREEN_DESKTOP : 0);
 }
 
+#ifdef AUDIO
 static void toggle_audio_display(VideoState *is)
 {
     int next = is->show_mode;
@@ -3151,6 +3469,7 @@
         is->show_mode = next;
     }
 }
+#endif
 
 static void refresh_loop_wait_event(VideoState *is, SDL_Event *event) {
     double remaining_time = 0.0;
@@ -3224,6 +3543,7 @@
             case SDLK_SPACE:
                 toggle_pause(cur_stream);
                 break;
+#ifdef AUDIO
             case SDLK_m:
                 toggle_mute(cur_stream);
                 break;
@@ -3235,23 +3555,32 @@
             case SDLK_9:
                 update_volume(cur_stream, -1, SDL_VOLUME_STEP);
                 break;
+#endif
             case SDLK_s: // S: Step to next frame
                 step_to_next_frame(cur_stream);
                 break;
+#ifdef AUDIO                
             case SDLK_a:
                 stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO);
                 break;
+#endif
             case SDLK_v:
                 stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO);
                 break;
             case SDLK_c:
                 stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO);
+#ifdef AUDIO
                 stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO);
+#endif
+#ifdef SUBTITLE
                 stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE);
+#endif
                 break;
+#ifdef SUBTITLE
             case SDLK_t:
                 stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE);
                 break;
+#endif
             case SDLK_w:
 #if CONFIG_AVFILTER
                 if (cur_stream->show_mode == SHOW_MODE_VIDEO && cur_stream->vfilter_idx < nb_vfilters - 1) {
@@ -3259,11 +3588,15 @@
                         cur_stream->vfilter_idx = 0;
                 } else {
                     cur_stream->vfilter_idx = 0;
+#ifdef AUDIO
                     toggle_audio_display(cur_stream);
+#endif
                 }
 #else
+#ifdef AUDIO
                 toggle_audio_display(cur_stream);
 #endif
+#endif
                 break;
             case SDLK_PAGEUP:
                 if (cur_stream->ic->nb_chapters <= 1) {
@@ -3295,8 +3628,10 @@
                         pos = -1;
                         if (pos < 0 && cur_stream->video_stream >= 0)
                             pos = frame_queue_last_pos(&cur_stream->pictq);
+#ifdef AUDIO                
                         if (pos < 0 && cur_stream->audio_stream >= 0)
                             pos = frame_queue_last_pos(&cur_stream->sampq);
+#endif
                         if (pos < 0)
                             pos = avio_tell(cur_stream->ic->pb);
                         if (cur_stream->ic->bit_rate)
@@ -3379,10 +3714,12 @@
                 case SDL_WINDOWEVENT_RESIZED:
                     screen_width  = cur_stream->width  = event.window.data1;
                     screen_height = cur_stream->height = event.window.data2;
+#ifdef AUDIO
                     if (cur_stream->vis_texture) {
                         SDL_DestroyTexture(cur_stream->vis_texture);
                         cur_stream->vis_texture = NULL;
                     }
+#endif
                 case SDL_WINDOWEVENT_EXPOSED:
                     cur_stream->force_refresh = 1;
             }
@@ -3433,12 +3770,17 @@
 
 static int opt_sync(void *optctx, const char *opt, const char *arg)
 {
+#ifdef AUDIO                
     if (!strcmp(arg, "audio"))
         av_sync_type = AV_SYNC_AUDIO_MASTER;
-    else if (!strcmp(arg, "video"))
+    else
+#endif
+        if (!strcmp(arg, "video"))
         av_sync_type = AV_SYNC_VIDEO_MASTER;
+#ifdef EXTCLOCK
     else if (!strcmp(arg, "ext"))
         av_sync_type = AV_SYNC_EXTERNAL_CLOCK;
+#endif
     else {
         av_log(NULL, AV_LOG_ERROR, "Unknown value for %s: %s\n", opt, arg);
         exit(1);
@@ -3461,8 +3803,10 @@
 static int opt_show_mode(void *optctx, const char *opt, const char *arg)
 {
     show_mode = !strcmp(arg, "video") ? SHOW_MODE_VIDEO :
+#ifdef AUDIO                
                 !strcmp(arg, "waves") ? SHOW_MODE_WAVES :
                 !strcmp(arg, "rdft" ) ? SHOW_MODE_RDFT  :
+#endif
                 parse_number_or_die(opt, arg, OPT_INT, 0, SHOW_MODE_NB-1);
     return 0;
 }
@@ -3491,8 +3835,12 @@
    }
    spec++;
    switch (spec[0]) {
+#ifdef AUDIO                
    case 'a' :    audio_codec_name = arg; break;
+#endif
+#ifdef SUBTITLE
    case 's' : subtitle_codec_name = arg; break;
+#endif
    case 'v' :    video_codec_name = arg; break;
    default:
        av_log(NULL, AV_LOG_ERROR,
@@ -3510,12 +3858,20 @@
     { "y", HAS_ARG, { .func_arg = opt_height }, "force displayed height", "height" },
     { "s", HAS_ARG | OPT_VIDEO, { .func_arg = opt_frame_size }, "set frame size (WxH or abbreviation)", "size" },
     { "fs", OPT_BOOL, { &is_full_screen }, "force full screen" },
+#ifdef AUDIO                
     { "an", OPT_BOOL, { &audio_disable }, "disable audio" },
+#endif
     { "vn", OPT_BOOL, { &video_disable }, "disable video" },
+#ifdef SUBTITLE
     { "sn", OPT_BOOL, { &subtitle_disable }, "disable subtitling" },
+#endif
+#ifdef AUDIO                
     { "ast", OPT_STRING | HAS_ARG | OPT_EXPERT, { &wanted_stream_spec[AVMEDIA_TYPE_AUDIO] }, "select desired audio stream", "stream_specifier" },
+#endif
     { "vst", OPT_STRING | HAS_ARG | OPT_EXPERT, { &wanted_stream_spec[AVMEDIA_TYPE_VIDEO] }, "select desired video stream", "stream_specifier" },
+#ifdef SUBTITLE
     { "sst", OPT_STRING | HAS_ARG | OPT_EXPERT, { &wanted_stream_spec[AVMEDIA_TYPE_SUBTITLE] }, "select desired subtitle stream", "stream_specifier" },
+#endif
     { "ss", HAS_ARG, { .func_arg = opt_seek }, "seek to a given position in seconds", "pos" },
     { "t", HAS_ARG, { .func_arg = opt_duration }, "play  \"duration\" seconds of audio/video", "duration" },
     { "bytes", OPT_INT | HAS_ARG, { &seek_by_bytes }, "seek by bytes 0=off 1=on -1=auto", "val" },
@@ -3534,20 +3890,30 @@
     { "exitonkeydown", OPT_BOOL | OPT_EXPERT, { &exit_on_keydown }, "exit on key down", "" },
     { "exitonmousedown", OPT_BOOL | OPT_EXPERT, { &exit_on_mousedown }, "exit on mouse down", "" },
     { "loop", OPT_INT | HAS_ARG | OPT_EXPERT, { &loop }, "set number of times the playback shall be looped", "loop count" },
+#ifdef FRAMEDROP
     { "framedrop", OPT_BOOL | OPT_EXPERT, { &framedrop }, "drop frames when cpu is too slow", "" },
+#endif
     { "infbuf", OPT_BOOL | OPT_EXPERT, { &infinite_buffer }, "don't limit the input buffer size (useful with realtime streams)", "" },
     { "window_title", OPT_STRING | HAS_ARG, { &window_title }, "set window title", "window title" },
 #if CONFIG_AVFILTER
     { "vf", OPT_EXPERT | HAS_ARG, { .func_arg = opt_add_vfilter }, "set video filters", "filter_graph" },
+#ifdef AUDIO                
     { "af", OPT_STRING | HAS_ARG, { &afilters }, "set audio filters", "filter_graph" },
 #endif
+#endif
+#ifdef AUDIO
     { "rdftspeed", OPT_INT | HAS_ARG| OPT_AUDIO | OPT_EXPERT, { &rdftspeed }, "rdft speed", "msecs" },
+#endif
     { "showmode", HAS_ARG, { .func_arg = opt_show_mode}, "select show mode (0 = video, 1 = waves, 2 = RDFT)", "mode" },
     { "default", HAS_ARG | OPT_AUDIO | OPT_VIDEO | OPT_EXPERT, { .func_arg = opt_default }, "generic catch all option", "" },
     { "i", OPT_BOOL, { &dummy}, "read specified file", "input_file"},
     { "codec", HAS_ARG, { .func_arg = opt_codec}, "force decoder", "decoder_name" },
+#ifdef AUDIO
     { "acodec", HAS_ARG | OPT_STRING | OPT_EXPERT, {    &audio_codec_name }, "force audio decoder",    "decoder_name" },
+#endif
+#ifdef SUBTITLE
     { "scodec", HAS_ARG | OPT_STRING | OPT_EXPERT, { &subtitle_codec_name }, "force subtitle decoder", "decoder_name" },
+#endif
     { "vcodec", HAS_ARG | OPT_STRING | OPT_EXPERT, {    &video_codec_name }, "force video decoder",    "decoder_name" },
     { "autorotate", OPT_BOOL, { &autorotate }, "automatically rotate video", "" },
     { NULL, },
@@ -3578,12 +3944,16 @@
            "q, ESC              quit\n"
            "f                   toggle full screen\n"
            "p, SPC              pause\n"
+#ifdef AUDIO
            "m                   toggle mute\n"
            "9, 0                decrease and increase volume respectively\n"
            "/, *                decrease and increase volume respectively\n"
            "a                   cycle audio channel in the current program\n"
+#endif
            "v                   cycle video channel\n"
+#ifdef SUBTITLE
            "t                   cycle subtitle channel in the current program\n"
+#endif
            "c                   cycle program\n"
            "w                   cycle video filters or show modes\n"
            "s                   activate frame-step mode\n"
@@ -3658,6 +4028,7 @@
         video_disable = 1;
     }
     flags = SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER;
+#ifdef AUDIO
     if (audio_disable)
         flags &= ~SDL_INIT_AUDIO;
     else {
@@ -3666,6 +4037,7 @@
         if (!SDL_getenv("SDL_AUDIO_ALSA_SET_BUFFER_SIZE"))
             SDL_setenv("SDL_AUDIO_ALSA_SET_BUFFER_SIZE","1", 1);
     }
+#endif
     if (display_disable)
         flags &= ~SDL_INIT_VIDEO;
     if (SDL_Init (flags)) {
